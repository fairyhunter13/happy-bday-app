name: CI

# LIGHTWEIGHT CI WORKFLOW
# This workflow handles core checks: lint, typecheck, build, security scan, coverage report
# All tests run in separate workflows triggered by the Unit Tests workflow
#
# Test Workflow Architecture:
#   1. Unit Tests (unit-tests.yml) - Primary test workflow with coverage gate
#   2. Downstream workflows triggered on Unit Tests success (>=81% coverage):
#      - integration-tests.yml
#      - chaos-tests.yml
#      - e2e-tests.yml
#      - mutation-tests.yml
#      - performance-smoke-tests.yml
#      - performance-load-tests.yml
#
# Required GitHub Secrets:
# - SOPS_AGE_KEY (required): Decrypt encrypted test environment files
# - CODECOV_TOKEN (required): Upload coverage reports to Codecov
# - SNYK_TOKEN (optional): Enable Snyk security scanning

on:
  pull_request:
  push:
    branches: [main, develop]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Core checks - always run
  lint-and-type-check:
    name: Lint and Type Check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and dependencies
        uses: ./.github/actions/setup-node-app

      - name: Run ESLint
        run: npm run lint

      - name: Run type check
        run: npm run typecheck

      - name: Check code formatting
        run: npm run format:check

  build:
    name: Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and dependencies
        uses: ./.github/actions/setup-node-app

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
          retention-days: 7

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and dependencies
        uses: ./.github/actions/setup-node-app
        with:
          install-dependencies: 'false'

      - name: Run npm audit
        run: npm audit --audit-level=critical

      - name: Run Snyk security scan
        if: env.SNYK_TOKEN != ''
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

  # Coverage report - processes coverage from Unit Tests workflow
  coverage-report:
    name: Coverage Report
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js and dependencies
        uses: ./.github/actions/setup-node-app

      - name: Validate Codecov Token
        id: codecov-check
        run: |
          if [ -z "${{ secrets.CODECOV_TOKEN }}" ]; then
            echo "::warning::CODECOV_TOKEN not configured. Coverage upload will be skipped."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "CODECOV_TOKEN is configured"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Download coverage from Unit Tests
        id: download-coverage
        run: |
          # Wait a bit for Unit Tests workflow to complete and upload coverage
          sleep 30

          # Try to download coverage artifact from the latest successful Unit Tests run
          set +e
          gh run list --workflow="Unit Tests" --branch="${{ github.head_ref || github.ref_name }}" --status=success --limit=1 --json databaseId --jq '.[0].databaseId' > run-id.txt 2>/dev/null

          if [ -s run-id.txt ] && [ "$(cat run-id.txt)" != "null" ]; then
            RUN_ID=$(cat run-id.txt)
            echo "Found Unit Tests run ID: $RUN_ID"
            gh run download "$RUN_ID" --name coverage-unit --dir coverage 2>/dev/null
            if [ -f coverage/coverage-summary.json ]; then
              echo "coverage_exists=true" >> $GITHUB_OUTPUT
            else
              echo "coverage_exists=false" >> $GITHUB_OUTPUT
              echo "Coverage artifact not found"
            fi
          else
            echo "No successful Unit Tests run found"
            echo "coverage_exists=false" >> $GITHUB_OUTPUT
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check coverage threshold
        if: steps.download-coverage.outputs.coverage_exists == 'true'
        run: bash scripts/coverage/check-thresholds.sh coverage/coverage-summary.json

      - name: Upload to Codecov
        if: steps.codecov-check.outputs.skip != 'true' && steps.download-coverage.outputs.coverage_exists == 'true'
        uses: codecov/codecov-action@v4
        with:
          directory: ./coverage
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

      - name: Download base coverage (from main branch)
        if: github.event_name == 'pull_request' && steps.download-coverage.outputs.coverage_exists == 'true'
        id: download-base-coverage
        run: |
          set +e
          gh run list --workflow="Unit Tests" --branch=main --status=success --limit=1 --json databaseId --jq '.[0].databaseId' > run-id.txt 2>/dev/null
          if [ -s run-id.txt ] && [ "$(cat run-id.txt)" != "null" ]; then
            RUN_ID=$(cat run-id.txt)
            echo "Found run ID: $RUN_ID"
            gh run download "$RUN_ID" --name coverage-unit --dir base-coverage 2>/dev/null
            if [ -f base-coverage/coverage-summary.json ]; then
              echo "base_coverage_exists=true" >> $GITHUB_OUTPUT
            else
              echo "base_coverage_exists=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No successful run found on main branch"
            echo "base_coverage_exists=false" >> $GITHUB_OUTPUT
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate coverage diff report
        if: github.event_name == 'pull_request' && steps.download-coverage.outputs.coverage_exists == 'true'
        run: |
          node -e "
          const fs = require('fs');

          function loadCoverage(path) {
            try { return JSON.parse(fs.readFileSync(path, 'utf8')); }
            catch (e) { return null; }
          }

          const currentCoverage = loadCoverage('coverage/coverage-summary.json');
          const baseCoverage = loadCoverage('base-coverage/coverage-summary.json');

          if (!currentCoverage) {
            console.log('Current coverage not found');
            process.exit(0);
          }

          const formatPct = (pct) => pct.toFixed(2);
          const formatDiff = (current, base) => {
            if (!base) return '(new)';
            const diff = current - base;
            const sign = diff >= 0 ? '+' : '';
            const emoji = diff > 0 ? 'ðŸ“ˆ' : diff < 0 ? 'ðŸ“‰' : 'âž¡ï¸';
            return \`\${sign}\${formatPct(diff)}% \${emoji}\`;
          };

          const c = currentCoverage.total;
          const b = baseCoverage?.total;

          let report = '## ðŸ“Š Coverage Report\\n\\n';

          if (baseCoverage) {
            report += '| Metric | Current | Base | Diff |\\n';
            report += '|--------|---------|------|------|\\n';
            report += \`| Lines | \${formatPct(c.lines.pct)}% | \${formatPct(b.lines.pct)}% | \${formatDiff(c.lines.pct, b.lines.pct)} |\\n\`;
            report += \`| Statements | \${formatPct(c.statements.pct)}% | \${formatPct(b.statements.pct)}% | \${formatDiff(c.statements.pct, b.statements.pct)} |\\n\`;
            report += \`| Functions | \${formatPct(c.functions.pct)}% | \${formatPct(b.functions.pct)}% | \${formatDiff(c.functions.pct, b.functions.pct)} |\\n\`;
            report += \`| Branches | \${formatPct(c.branches.pct)}% | \${formatPct(b.branches.pct)}% | \${formatDiff(c.branches.pct, b.branches.pct)} |\\n\`;
          } else {
            report += '| Metric | Coverage |\\n';
            report += '|--------|----------|\\n';
            report += \`| Lines | \${formatPct(c.lines.pct)}% |\\n\`;
            report += \`| Statements | \${formatPct(c.statements.pct)}% |\\n\`;
            report += \`| Functions | \${formatPct(c.functions.pct)}% |\\n\`;
            report += \`| Branches | \${formatPct(c.branches.pct)}% |\\n\`;
            report += '\\n> Base coverage not available for comparison\\n';
          }

          fs.writeFileSync('coverage-diff.md', report);
          console.log(report);
          "

      - name: Comment coverage diff on PR
        if: github.event_name == 'pull_request' && steps.download-coverage.outputs.coverage_exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            try {
              const report = fs.readFileSync('coverage-diff.md', 'utf8');

              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const botComment = comments.data.find(comment =>
                comment.user.type === 'Bot' &&
                comment.body.includes('ðŸ“Š Coverage Report')
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: report
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: report
                });
              }
            } catch (e) {
              console.log('Could not post coverage comment:', e.message);
            }

  # Summary check - verifies core checks passed
  all-checks-passed:
    name: All Core Checks Passed
    needs:
      - lint-and-type-check
      - build
      - security-scan
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Check all jobs
        run: |
          FAILED=""
          if [[ "${{ needs.lint-and-type-check.result }}" != "success" ]]; then FAILED="$FAILED lint-and-type-check"; fi
          if [[ "${{ needs.build.result }}" != "success" ]]; then FAILED="$FAILED build"; fi
          if [[ "${{ needs.security-scan.result }}" != "success" ]]; then FAILED="$FAILED security-scan"; fi

          if [[ -n "$FAILED" ]]; then
            echo "::error::Core checks failed:$FAILED"
            exit 1
          fi
          echo "All core checks passed!"
          echo ""
          echo "Note: Tests run in separate workflows:"
          echo "  - Unit Tests (triggers all downstream tests)"
          echo "  - Integration Tests"
          echo "  - Chaos Tests"
          echo "  - E2E Tests"
          echo "  - Mutation Tests"
          echo "  - Performance Smoke Tests"
          echo "  - Performance Load Tests"
