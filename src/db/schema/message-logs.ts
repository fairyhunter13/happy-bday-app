import { pgTable, uuid, varchar, text, timestamp, integer, index, unique } from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';
import { users } from './users';

/**
 * Message status enum
 * Tracks the lifecycle of a birthday message
 */
export const MessageStatus = {
  SCHEDULED: 'SCHEDULED',   // Pre-calculated, waiting to be enqueued
  QUEUED: 'QUEUED',        // In RabbitMQ queue
  SENDING: 'SENDING',      // Being processed by worker
  SENT: 'SENT',           // Successfully delivered
  FAILED: 'FAILED',       // Failed after max retries
  RETRYING: 'RETRYING',   // Temporary failure, will retry
} as const;

export type MessageStatusType = typeof MessageStatus[keyof typeof MessageStatus];

/**
 * Message type enum
 * Supports multiple message types via Strategy Pattern
 */
export const MessageType = {
  BIRTHDAY: 'BIRTHDAY',
  ANNIVERSARY: 'ANNIVERSARY',
} as const;

export type MessageTypeType = typeof MessageType[keyof typeof MessageType];

/**
 * Message Logs table - partitioned by scheduled_send_time (monthly)
 *
 * Design considerations:
 * - Monthly partitioning for 10-100x query performance at scale
 * - Idempotency via unique constraint (user_id, message_type, delivery_date)
 * - Pre-composed message content to avoid runtime computation
 * - Tracks API response for debugging and monitoring
 *
 * Partitioning strategy:
 * - CREATE TABLE message_logs_2025_01 PARTITION OF message_logs
 *   FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
 *
 * Note: Partitions must be created programmatically (see migrations)
 */
export const messageLogs = pgTable(
  'message_logs',
  {
    id: uuid('id')
      .primaryKey()
      .default(sql`gen_random_uuid()`),

    // Foreign key to users table (CASCADE delete)
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),

    // Message type discriminator (BIRTHDAY, ANNIVERSARY, etc.)
    messageType: varchar('message_type', { length: 50 })
      .notNull(),

    // Pre-composed message content
    // Generated by MessageStrategy.composeMessage()
    messageContent: text('message_content')
      .notNull(),

    // Scheduled send time in UTC
    // Calculated as: 9am user's local time -> UTC
    scheduledSendTime: timestamp('scheduled_send_time', { withTimezone: true, mode: 'date' })
      .notNull(),

    // Actual send time (when message was delivered)
    actualSendTime: timestamp('actual_send_time', { withTimezone: true, mode: 'date' }),

    // Status tracking
    status: varchar('status', { length: 20 })
      .notNull()
      .default(MessageStatus.SCHEDULED),

    // Retry tracking
    retryCount: integer('retry_count')
      .notNull()
      .default(0),

    lastRetryAt: timestamp('last_retry_at', { withTimezone: true, mode: 'date' }),

    // API response tracking
    apiResponseCode: integer('api_response_code'),

    apiResponseBody: text('api_response_body'),

    errorMessage: text('error_message'),

    // Idempotency key: prevents duplicate messages
    // Format: {user_id}:{message_type}:{delivery_date}
    // Example: "123e4567-e89b-12d3-a456-426614174000:BIRTHDAY:2025-12-30"
    idempotencyKey: varchar('idempotency_key', { length: 255 })
      .notNull()
      .unique(),

    // Timestamps
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'date' })
      .notNull()
      .defaultNow(),

    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'date' })
      .notNull()
      .defaultNow(),
  },
  (table) => ({
    // Index: user_id (for CASCADE delete performance)
    userIdIdx: index('idx_message_logs_user_id')
      .on(table.userId),

    // Index: status (for filtering by status)
    statusIdx: index('idx_message_logs_status')
      .on(table.status),

    // Index: scheduled_send_time (for time-based queries)
    scheduledTimeIdx: index('idx_message_logs_scheduled_time')
      .on(table.scheduledSendTime),

    // Composite index: (message_type, status, scheduled_send_time)
    // Optimizes scheduler queries:
    // "Find all SCHEDULED BIRTHDAY messages in next hour"
    schedulerIdx: index('idx_message_logs_scheduler')
      .on(table.messageType, table.status, table.scheduledSendTime),

    // Composite index: (scheduled_send_time, status) with WHERE clause
    // Optimizes recovery queries:
    // "Find all SCHEDULED/RETRYING/FAILED messages in past 24h"
    recoveryIdx: index('idx_message_logs_recovery')
      .on(table.scheduledSendTime, table.status)
      .where(
        sql`${table.status} IN ('SCHEDULED', 'RETRYING', 'FAILED')`
      ),

    // Unique constraint: idempotency_key
    // Database-level enforcement to prevent duplicate messages
    idempotencyUniqueIdx: unique('idx_message_logs_idempotency')
      .on(table.idempotencyKey),
  })
);

// Type inference for select/insert operations
export type MessageLog = typeof messageLogs.$inferSelect;
export type NewMessageLog = typeof messageLogs.$inferInsert;
